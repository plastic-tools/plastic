import { track, cache, $Reuse, reuse, reactor } from "@plastic/reactor";
import {
  RendererInput,
  RenderCommand,
  isPlatformCommand,
  isComponentCommand,
  Engine
} from "./types";
import Responder from "./responder";
import { DOMEngine } from "./dom/engine";
import { ComponentEngine } from "./component.engine";
import pool from "./pool";

/**
 * Renders a RenderCommand into a dom node that can be inserted into a tree.
 * @todo more docs
 */
export class Renderer extends Responder {
  constructor(input: RendererInput, readonly parent: Renderer = null) {
    super();
    if (input) this.input = input;
  }

  /**
   * Input to the renderer. Changing this property will eventually update
   * the dom.
   */
  @track
  input: RendererInput;

  @track
  root: Node;

  @cache
  get command(): RenderCommand {
    let { input } = this;
    while (input && "function" === typeof input) input = input();
    return input as RenderCommand;
  }

  /** Renderer key, if supplied in command */
  get key() {
    const { command } = this;
    return !!command && "object" === typeof command && command.key;
  }

  /** Accelerate reuse() */
  [$Reuse](prior: Renderer) {
    const { parent, input } = this;
    return prior.parent === parent && reuse(prior.input, input) === input;
  }

  // ..........................
  // COMPONENT NODE PROPERTIES
  //

  @cache
  protected get engine(): Engine {
    const { command } = this;
    const prior = cache.prior;
    let ret: Engine = null;
    if (isPlatformCommand(command))
      ret = prior instanceof DOMEngine ? prior : pool.get(DOMEngine);
    if (isComponentCommand(command))
      ret =
        prior instanceof ComponentEngine ? prior : pool.get(ComponentEngine);
    if (ret !== prior) {
      if (prior) pool.release(prior);
      if (ret) ret.owner = this;
    }
    return null;
  }

  /** Context passed down (regarldess of whether component) */
  get context() {
    const { parent } = this;
    return (
      (parent &&
        ((parent.engine && parent.engine.childContext) || parent.context)) ||
      {}
    );
  }

  /**
   * Returns the DOM node generated by this renderer. Attempts to reuse the
   * node whenever possible. If the returned node value changes or becomes
   * null and the previous node was in the DOM, it will be swapped/replaced.
   * However, it is the responsibility of the parent to insert the node into
   * the document in the first place.
   */
  get node(): Node {
    const { engine } = this;
    return engine && engine.node;
  }

  private refresh = () => this.node;

  register(root: Node = null) {
    this.root = root;
    reactor.register(this.refresh);
  }

  unregister() {
    this.root = null;
    reactor.unregister(this.refresh);
  }

  /**
   * Called on the renderer by a parent when it's output node is about to
   * be inserted into a document.  Notifies any children and child component
   * as needed.
   *
   * @param mounter the renderer mounting the this renderer.
   */
  willMount() {
    const { engine } = this;
    engine && engine.willMount();
  }

  /**
   * Called just after the renderer's DOM is inserted into a document for
   * the first time.
   */
  didMount() {
    const { engine } = this;
    engine && engine.didMount();
  }

  /**
   * Called just before the renderer's DOM element is about to be removed
   * from the document.
   */
  willUnmount() {
    const { engine } = this;
    engine && engine.willUnmount();
  }
}

export default Renderer;
